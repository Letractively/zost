# CONFIGURE ABAIXO O NOME DO BANCO DE DADOS COLOCANDO-O ENTRE ASPAS NA
# ATRIBUIÇÃO DA VARIÁVEL E SEM ASPAS NO COMANDO "USE"
SET @BANCODEDADOS := 'BANCODEOBRAS3';
USE BANCODEOBRAS3;

# ==============================================================================
# CONSIDERAÇÕES IMPORTANTES...
# NA FUNÇÃO "FNC_GET_PROPOSAL_VALUE", QUANDO NÃO SE USAVA SUBTOTAL, NÃO ARREDONDAVA PARA AS CASAS DECIMAIS INDICADAS
# NA FUNÇÃO "FNC_GET_ITEM_VALUE", MAIS DOIS PARÂMETROA FORAM COLOCADOS PARA SABER SE O REAJUSTE DA PROPOSTA QUE CONTÉM O ITEM DEVE SER RATEADO
# A FUNÇÃO "FNC_GET_BRUTE_PROFIT" FOI ALTERADA PARA ATENDER AS NECESSIDADES DA NOVA "FNC_GET_ITEM_VALUE"
# A FUNÇÃO "FNC_GET_FORMATTED_CAPACITY" FOI ALTERADA PARA USAR ARGUMENTOS E VARIÁVEIS DOUBLE
# A FUNÇÃO "FNC_GET_FORMATTED_PERCENTUAL" FOI ALTERADA PARA USAR ARGUMENTOS E VARIÁVEIS DOUBLE
# A FUNÇÃO "FNC_GET_FORMATTED_PROPOSAL_REAJUST" FOI ALTERADA PARA USAR ARGUMENTOS E VARIÁVEIS DOUBLE
# A FUNÇÃO "FNC_GET_ICMS_MULTIPLIER" FOI ALTERADA PARA USAR ARGUMENTOS E VARIÁVEIS DOUBLE
# A FUNÇÃO "FNC_GET_REAJUST_MULTIPLIER" FOI ALTERADA PARA USAR ARGUMENTOS E VARIÁVEIS DOUBLE
# O PROCEDURE "PRC_SET_CORRECT_REAJUST_BEFORE_POST" FOI ALTERADO PARA USAR ARGUMENTOS E VARIÁVEIS DOUBLE
# A FUNÇÃO "FNC_GET_FORMATTED_CURRENCY_VALUE" FOI AJUSTADA PARA USAR ROUND
# NOVA VIEW (VIW_FINISHED_SITUATIONS) QUE RETORNA SITUACOES QUE FINALIZAM UM OBRA (GANHA, PERDIDA E SUSPENSA). FUTURAMENTE UM NOVO CAMPO PODE SER INSERIDO NA TABELA DE SITUACOES PARA INDICAR QUE A MESMA FINALIZA UMA OBRA, MAS POR ENQUANTO O RETORNO SERÁ CONSTANTE PARA ESTAS 3 SITUAÇÕES
# NOVA VIEW (VIW_ACTIVE_SITUATIONS) QUE RETORNA SITUAÇÕES QUE MANTÉM A OBRA ATIVA. O RESULTADO SERÁ SEMPRE O COMPLEMENTO DA VIEW "VIW_ULTIMATE_SITUATIONS"
# ==============================================================================

# == VARIAVEIS TEMPORRIAS ======================================================
# A VARIÁVEL "SYNCHRONIZING" É ÚTIL APENAS NO CLIENTE POIS LÁ PODE HAVER AÇÕES
# EM TABELAS GERADAS DURANTE UMA SINCRONIZAÇÃO OU NÃO. NO SERVIDOR, QUANDO
# "SERVERSIDE" = TRUE, ESTA VARIÁVEL É IGNORADA POIS NO SERVIDOR ESTAREMOS
# SEMPRE SINCRONIZANDO

# O USO DESTAS VARIÁVEIS AQUI SÓ É EFETIVO SE HOUVER MANIPULÇÃO DE DADOS NESTE
# SCRIPT. SERVERSIDE = TRUE É CONDIÇÃO SUFICIENTE PARA DIZER QUE SE ESTÁ
# SINCRONIZANDO NO SERVIDOR POIS O SERVIDOR NÃO É ACESSÍVEL DIRETAMENTE, APENAS
# VIA SINCRONIZÇÃO
SET @SYNCHRONIZING = FALSE;
SET @CURRENTLOGGEDUSER = 1;
SET @SERVERSIDE = TRUE;
SET @ADJUSTINGDB = TRUE;
SET FOREIGN_KEY_CHECKS = 0;
# ATENÇÃO: QUANDO FOREIGN_KEY_CHECKS ESTÁ DESATIVADO NENHUMA FUNÇÃO RELACIONADA
# A INTEGRIDADE REFERENCIAL SERÁ EXECUTADA A SABER: ONDELETE E ONUPDATE. SE SUA
# INTENÇÃO É EXCLUIR PROPOSITALMENTE ALGUNS REGISTROS A TÍTULO DE LIMPEZA, ISSO
# DEVE SER FEITO QUANDO "FOREIGN_KEY_CHECKS = 1" DO CONTRÁRIO O BANCO FICARÁ
# INCONSISTENTE (REGISTROS ÓRFÃOS)
# ==============================================================================

# == STORED PROCEDURES =========================================================
DROP FUNCTION IF EXISTS FNC_GET_PROPOSAL_VALUE;
DELIMITER ¬
CREATE FUNCTION FNC_GET_PROPOSAL_VALUE(IDPROPOSAL INTEGER UNSIGNED
                                      ,SUBTOTAL BOOLEAN
                                      ,AUTODETECTEXCHANGE BOOLEAN
                                      ,EXCHANGEVALUES VARCHAR(39)
                                      ,DECIMALPLACES TINYINT)
RETURNS DOUBLE
SQL SECURITY DEFINER
BEGIN
	DECLARE VALOR_PROPOSTA DOUBLE;
  DECLARE PROPOSALREAJUST DOUBLE;
  DECLARE USEPROPOSALREAJUST BOOLEAN;

	  # OS VALORES OBTIDOS DOS ITENS COM "FNC_GET_ITEM_VALUE" SÃO INTEGRAIS (COM
    # TODAS AS CASAS DECIMAIS), LOGO O SEU SOMATÓRIO GERA UM VALOR PRECISO,
    # ENTRETANTO NAS PROPOSTAS GERADAS OS VALORES DE CADA ITEM SÃO APRESENTADOS
    # ARREDONDADOS PARA 2 CASAS DECIMAIS E O VALOR FINAL DA PROPOSTA FAZ O
    # CÁLCULO SOMANDO OS VALORES REAIS DE CADA UM DOS ITENS (SEM ARREDONDAMENTO)
    # O QUE CAUSAVA UM DISCREPÂNCIA ENTRE O SOMATÓRIO DO QUE É APRESENTADO E O
    # VALOR FINAL DA PROPOSTA EXIBIDO. A FIM DE RESOLVER ESTA DISCREPÂNCIA, MAIS
    # UM PARÂMETRO FOI INCLUÍDO NESTA FUNÇÃO (FNC_GET_PROPOSAL_VALUE) PARA
    # INFORMAR SE DEVEMOS ARREDONDAR O VALOR DE CADA ITEM ANTES DE SOMAR E PARA
    # QUANTAS CASAS DECIMAIS ISSO DEVE SER FEITO. ESTA NÃO É A FORMA QUE RETORNA
    # RESULTADOS MAIS PRECISOS, MAS É A QUE RETORNA OS VALORES MAIS COERENTES
    # PARA EXIBIÇÃO. O CORRETO SERIA SOMAR TODOS OS VALORES DE FORMA INTEGRAL
    # PARA APENAS NO FINAL REALIZAR O ARREDONDAMENTO.

    # OBTENDO O REAJUSTE DA PROPOSTA
    SET PROPOSALREAJUST := FNC_GET_PROPOSAL_REAJUST_MULTIPLIER(IDPROPOSAL);
    SET USEPROPOSALREAJUST := PROPOSALREAJUST <> 1 AND NOT SUBTOTAL;

    IF DECIMALPLACES > -1 THEN

      SELECT SUM(ROUND(FNC_GET_ITEM_VALUE(IN_ITENS_ID,FALSE,AUTODETECTEXCHANGE,EXCHANGEVALUES,USEPROPOSALREAJUST,PROPOSALREAJUST),DECIMALPLACES))
        INTO VALOR_PROPOSTA
        FROM ITENS
       WHERE IN_PROPOSTAS_ID = IDPROPOSAL;

    ELSE

      SELECT SUM(FNC_GET_ITEM_VALUE(IN_ITENS_ID,FALSE,AUTODETECTEXCHANGE,EXCHANGEVALUES,USEPROPOSALREAJUST,PROPOSALREAJUST))
        INTO VALOR_PROPOSTA
        FROM ITENS
       WHERE IN_PROPOSTAS_ID = IDPROPOSAL;

    END IF;

	RETURN VALOR_PROPOSTA;

END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_ITEM_VALUE;
DELIMITER ¬
CREATE FUNCTION FNC_GET_ITEM_VALUE(ITEMID INTEGER UNSIGNED
                                  ,UNITARY BOOLEAN
                                  ,AUTODETECTEXCHANGE BOOLEAN
                                  ,EXCHANGEVALUES VARCHAR(39)
                                  ,USEPROPOSALREAJUST BOOLEAN
                                  ,PROPOSALREAJUST DOUBLE)
RETURNS DOUBLE
SQL SECURITY DEFINER
BEGIN
	DECLARE ITEM_VALUE DOUBLE DEFAULT 0;
  DECLARE PROPOSALID INTEGER UNSIGNED;

	SELECT SUM(EDI.FL_VALORUNITARIO) * FNC_GET_ICMS_MULTIPLIER(OBR.IN_OBRAS_ID) * IF(NOT UNITARY, ITE.SM_QUANTIDADE * FNC_GET_REAJUST_MULTIPLIER(ITE.FL_DESCONTOPERC), 1 )
       , PRO.IN_PROPOSTAS_ID
	  INTO ITEM_VALUE
       , PROPOSALID
	  FROM EQUIPAMENTOSDOSITENS EDI
	  JOIN ITENS ITE USING (IN_ITENS_ID)
	  JOIN PROPOSTAS PRO USING (IN_PROPOSTAS_ID)
	  JOIN OBRAS OBR USING (IN_OBRAS_ID)
	 WHERE EDI.IN_ITENS_ID = ITEMID;

  IF USEPROPOSALREAJUST THEN
    SET ITEM_VALUE := ITEM_VALUE * PROPOSALREAJUST;
  END IF;

	IF AUTODETECTEXCHANGE THEN
		RETURN ITEM_VALUE * FNC_GET_EXCHANGE_MULTIPLIER(ITEMID,NULL);
	ELSE
		IF NOT EXCHANGEVALUES IS NULL THEN
			RETURN ITEM_VALUE * FNC_GET_EXCHANGE_MULTIPLIER(ITEMID,EXCHANGEVALUES);
		ELSE
			RETURN ITEM_VALUE;
		END IF;
	END IF;
END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_PROPOSAL_REAJUST;
DROP FUNCTION IF EXISTS FNC_GET_PROPOSAL_REAJUST_MULTIPLIER;
DELIMITER ¬
CREATE FUNCTION FNC_GET_PROPOSAL_REAJUST_MULTIPLIER(PROPOSALID INTEGER UNSIGNED)
RETURNS DOUBLE
SQL SECURITY DEFINER
BEGIN
	DECLARE DESCONTOPERC DOUBLE;
	DECLARE DESCONTOVAL DOUBLE;
  DECLARE VALORDAPROPOSTA DOUBLE;

  # OBTENDO O VALOR DA PROPOSTA SEM REAJUSTES
  SELECT SUM(FNC_GET_ITEM_VALUE(IN_ITENS_ID,FALSE,TRUE,NULL,FALSE,NULL))
    INTO VALORDAPROPOSTA
    FROM ITENS
   WHERE IN_PROPOSTAS_ID = PROPOSALID;

  # OBTENDO OS REAJUSTES DA PROPOSTA
  SELECT FL_DESCONTOPERC
       , FL_DESCONTOVAL
    INTO DESCONTOPERC
       , DESCONTOVAL
    FROM PROPOSTAS
   WHERE IN_PROPOSTAS_ID = PROPOSALID;

  IF NOT DESCONTOVAL IS NULL THEN

    # FNC_GET_REAJUST_MULTIPLIER USA COMO PARAMETRO UM VALOR EM PERCENTUAL E
    # RETORNA UM MULTIPLICADOR. POR ISSO FOI PRECISO MULTIPLICAR O VALOR POR 100
    # DE FORMA QUE A FUNÇÃO PUDESSE SER USADA
    RETURN FNC_GET_REAJUST_MULTIPLIER(DESCONTOVAL / VALORDAPROPOSTA * 100);

  ELSE

    RETURN FNC_GET_REAJUST_MULTIPLIER(DESCONTOPERC);

  END IF;
                                                                              
END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_BRUTE_PROFIT;
DELIMITER ¬
CREATE FUNCTION FNC_GET_BRUTE_PROFIT(ITEMID INTEGER UNSIGNED)
RETURNS DOUBLE
SQL SECURITY DEFINER
BEGIN 
	DECLARE LUCROSOMADOS DOUBLE;
	DECLARE REAJUSTE DOUBLE;
	DECLARE ICMS DOUBLE;
	DECLARE IDOBRA INTEGER UNSIGNED;
	
	SELECT OBR.IN_OBRAS_ID 
	  INTO IDOBRA 
	  FROM OBRAS OBR 
	  JOIN PROPOSTAS PRO USING (IN_OBRAS_ID) 
	  JOIN ITENS ITE USING (IN_PROPOSTAS_ID)
	 WHERE ITE.IN_ITENS_ID = ITEMID;
	 
	 SET ICMS := FNC_GET_ICMS_MULTIPLIER(IDOBRA); 
	 
	   SELECT ITE.FL_DESCONTOPERC
	        , SUM(EDI.FL_VALORUNITARIO * EDI.FL_LUCROBRUTO / 100) * ICMS
  	   INTO REAJUSTE, LUCROSOMADOS
	     FROM EQUIPAMENTOSDOSITENS EDI
	     JOIN ITENS ITE USING (IN_ITENS_ID)
	     JOIN PROPOSTAS PRO USING (IN_PROPOSTAS_ID)
  	   JOIN OBRAS OBR USING (IN_OBRAS_ID)
	    WHERE EDI.IN_ITENS_ID = ITEMID
	 GROUP BY ITE.IN_ITENS_ID; 
	 
	 RETURN LUCROSOMADOS / FNC_GET_ITEM_VALUE(ITEMID,TRUE,FALSE,NULL,FALSE,NULL) * 100 + REAJUSTE;
END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_FORMATTED_CAPACITY;
DELIMITER ¬
CREATE FUNCTION FNC_GET_FORMATTED_CAPACITY(CAPACITY DOUBLE
                                          ,UNIT VARCHAR(10))
RETURNS VARCHAR(20)
SQL SECURITY DEFINER
BEGIN 
	DECLARE UNFORMATTED_CAPACITY VARCHAR(20);
	DECLARE FORMATTED_CAPACITY VARCHAR(20);

  # O ARREDONDAMENTO USADO POR FORMAT E POR ROUND PARECEM SER DIFERENTES, LOGO,
  # USA-SE O ARREDONDAMENTO DE ROUND E APLICA EM FORMAT, QUE NESTE CASO NÃO DEVE
  # FAZER NADA COM AS CASAS DECIMAIS
	SET UNFORMATTED_CAPACITY := FORMAT(ROUND(CAPACITY,2),2);                    # 1,000.00
	SET UNFORMATTED_CAPACITY := REPLACE(UNFORMATTED_CAPACITY,'.',';'); # 1,000;00
	SET UNFORMATTED_CAPACITY := REPLACE(UNFORMATTED_CAPACITY,',','.'); # 1.000;00
	SET UNFORMATTED_CAPACITY := REPLACE(UNFORMATTED_CAPACITY,';',','); # 1.000,00
	
	SET FORMATTED_CAPACITY := CONCAT(UNFORMATTED_CAPACITY,' ',UNIT);   # 1.000,00 BTU
	
	IF LOCATE(',00',FORMATTED_CAPACITY) > 0 THEN
		SET FORMATTED_CAPACITY := REPLACE(FORMATTED_CAPACITY,',00','');  # 1.000 BTU
	END IF;
	
	RETURN FORMATTED_CAPACITY;
END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_FORMATTED_PERCENTUAL;
DELIMITER ¬
CREATE FUNCTION FNC_GET_FORMATTED_PERCENTUAL(PERCENTUAL DOUBLE
                                            ,OUTPUTPOSITIVESIGNAL BOOLEAN)
RETURNS VARCHAR(20)
SQL SECURITY DEFINER
BEGIN
	DECLARE UNFORMATTED_PERCENTUAL VARCHAR(20);
	DECLARE FORMATTED_PERCENTUAL VARCHAR(20);
	DECLARE SIGNAL CHAR(1) DEFAULT '';

	IF OUTPUTPOSITIVESIGNAL AND (PERCENTUAL > 0) THEN
		SET SIGNAL := '+';
	END IF;

	SET UNFORMATTED_PERCENTUAL := FORMAT(ROUND(PERCENTUAL,2),2);                    # 1,000.00
	SET UNFORMATTED_PERCENTUAL := REPLACE(UNFORMATTED_PERCENTUAL,'.',';'); # 1,000;00
	SET UNFORMATTED_PERCENTUAL := REPLACE(UNFORMATTED_PERCENTUAL,',','.'); # 1.000;00
	SET UNFORMATTED_PERCENTUAL := REPLACE(UNFORMATTED_PERCENTUAL,';',','); # 1.000,00

	SET FORMATTED_PERCENTUAL := CONCAT(SIGNAL,UNFORMATTED_PERCENTUAL,' %'); # 1.000,00 %
	
	RETURN FORMATTED_PERCENTUAL;
END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_FORMATTED_PROPOSAL_REAJUST;
DELIMITER ¬
CREATE FUNCTION FNC_GET_FORMATTED_PROPOSAL_REAJUST(IDPROPOSAL INTEGER UNSIGNED
                                                  ,CURRENCYSYMBOL VARCHAR(4))
RETURNS VARCHAR(20)
SQL SECURITY DEFINER
BEGIN 
	DECLARE DESCONTOPERC DOUBLE;
	DECLARE DESCONTOVAL DOUBLE;

	SELECT FL_DESCONTOPERC
	     , FL_DESCONTOVAL
	  INTO DESCONTOPERC
	     , DESCONTOVAL
	  FROM PROPOSTAS
	 WHERE IN_PROPOSTAS_ID = IDPROPOSAL;
	 
	IF NOT DESCONTOPERC IS NULL THEN
	 	RETURN FNC_GET_FORMATTED_PERCENTUAL(DESCONTOPERC,TRUE);
	ELSE 
	 	RETURN FNC_GET_FORMATTED_CURRENCY_VALUE(DESCONTOVAL,CURRENCYSYMBOL,TRUE);
	END IF;
END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_ICMS_MULTIPLIER;
DELIMITER ¬
CREATE FUNCTION FNC_GET_ICMS_MULTIPLIER(OBRAID INTEGER UNSIGNED) 
RETURNS DOUBLE
SQL SECURITY DEFINER
BEGIN 
	DECLARE MAXIMUM_ICMS DOUBLE DEFAULT 18;
	DECLARE OBRA_ICMS DOUBLE DEFAULT 0;
	
	SELECT MAX(FL_VALOR)
	  INTO MAXIMUM_ICMS
	  FROM ICMS;
	  
	SELECT FL_ICMS
	  INTO OBRA_ICMS
	  FROM OBRAS 
	 WHERE IN_OBRAS_ID = OBRAID;
	 
	RETURN (100 - MAXIMUM_ICMS) / (100 - OBRA_ICMS); 
END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_REAJUST_MULTIPLIER;
DELIMITER ¬
CREATE FUNCTION FNC_GET_REAJUST_MULTIPLIER(REAJUST DOUBLE) 
RETURNS DOUBLE
SQL SECURITY DEFINER
BEGIN 
	IF REAJUST > 0 THEN
		RETURN REAJUST / 100 + 1;
	ELSE
		IF REAJUST < 0 THEN
			RETURN (100 - ABS(REAJUST)) / 100;
		ELSE
			RETURN 1;
		END IF;
	END IF;
END; ¬
DELIMITER ;

DROP PROCEDURE IF EXISTS PRC_SET_CORRECT_REAJUST_BEFORE_POST;
DELIMITER ¬
CREATE PROCEDURE PRC_SET_CORRECT_REAJUST_BEFORE_POST(INOUT REAJUSTPERC DOUBLE, INOUT REAJUSTVAL DOUBLE)
SQL SECURITY DEFINER
BEGIN 
	IF (REAJUSTPERC IS NULL) AND (REAJUSTVAL IS NULL) THEN 
		SET REAJUSTVAL := 0; 
		SET REAJUSTPERC := NULL;
	ELSE
		IF (NOT REAJUSTPERC IS NULL) AND (NOT REAJUSTVAL IS NULL) THEN
			SET REAJUSTPERC := NULL;
		END IF;
	END IF;
END; ¬
DELIMITER ;

DROP FUNCTION IF EXISTS FNC_GET_FORMATTED_CURRENCY_VALUE;
DELIMITER ¬
CREATE FUNCTION FNC_GET_FORMATTED_CURRENCY_VALUE(CURRENCYVALUE DOUBLE
                                                ,CURRENCYSYMBOL VARCHAR(4)
                                                ,OUTPUTPOSITIVESIGNAL BOOLEAN)
RETURNS VARCHAR(30) CHARSET latin1
SQL SECURITY DEFINER
BEGIN
	DECLARE UNFORMATTED_CURRENCYVALUE VARCHAR(30);
	DECLARE FORMATTED_CURRENCYVALUE VARCHAR(30);
	DECLARE SIGNAL CHAR(1) DEFAULT '';

	IF (CURRENCYVALUE > 0) AND OUTPUTPOSITIVESIGNAL THEN
		SET SIGNAL := '+';
	ELSE
		IF CURRENCYVALUE < 0 THEN
			SET SIGNAL := '-';
		END IF;
	END IF;

	SET UNFORMATTED_CURRENCYVALUE := FORMAT(ABS(ROUND(CURRENCYVALUE,2)),2);      # 1,000.00
	SET UNFORMATTED_CURRENCYVALUE := REPLACE(UNFORMATTED_CURRENCYVALUE,'.',';'); # 1,000;00
	SET UNFORMATTED_CURRENCYVALUE := REPLACE(UNFORMATTED_CURRENCYVALUE,',','.'); # 1.000;00
	SET UNFORMATTED_CURRENCYVALUE := REPLACE(UNFORMATTED_CURRENCYVALUE,';',','); # 1.000,00

	SET FORMATTED_CURRENCYVALUE := CONCAT(SIGNAL,CURRENCYSYMBOL,' ',UNFORMATTED_CURRENCYVALUE); # +R$ 1.000,00

	RETURN FORMATTED_CURRENCYVALUE;
END; ¬
DELIMITER ;

# == VIEWS =====================================================================

# FUTURAMENTE HAVERÁ 3 TIPOS DE SITUACAO
# - ORDINÁRIA   : SIMPLES. NADA DE ESPECIAL
# - FINALIZADORA: INDICAM QUE UMA OBRA FOI FINALIZADA
# - ATIVA       : INDICAM QUE UMA OBRA ESTA EM ANDAMENTO COM ALGUMA PREVISÃO DE CONCLUSÃO
CREATE VIEW VIW_FINISHED_SITUATIONS
         AS SELECT TI_SITUACOES_ID
              FROM SITUACOES
             WHERE VA_DESCRICAO IN ('GANHA','PERDIDA','SUSPENSA');

CREATE VIEW VIW_ACTIVE_SITUATIONS
         AS SELECT TI_SITUACOES_ID
              FROM SITUACOES
             WHERE VA_DESCRICAO IN ('EM ANDAMENTO NIVEL A','EM ANDAMENTO NIVEL B','EM ANDAMENTO NIVEL M');

# ==============================================================================
# A PARTIR DESTE PONTO TODAS AS AÇÕES FARÃO USO DA INTEGRIDADE REFERENCIAL, O
# QUE SIGNIFICA QUE OS DADOS TEM DE ESTAR CORRETOS
SET FOREIGN_KEY_CHECKS = 1;
# ==============================================================================